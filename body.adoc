[[body]]
== CSRs

[NOTE]
[%unbreakable]
====
_CSR field specifications (such as WARL and WPRI) can be found in the link:https://riscv.org/technical/specifications/[RISC-V Instruction Set Manual] vol. II (Privileged Architecture), section 2.3._
====

=== Machine Control Transfer Record Control (`mctrcontrol`)

The `mctrcontrol` register is a 64-bit read/write register that enables and configures the CTR capability.

.Machine Control Transfer Record Control Register Format
[wavedrom, , ]
....
{reg: [    
    {bits:  1, name: 'M'},
    {bits:  1, name: 'S'},
    {bits:  1, name: 'U'},
    {bits:  4, name: '0'},
    {bits:  1, name: 'RASEMU'},
    {bits:  1, name: 'MTE'},
    {bits:  1, name: 'STE'},
    {bits:  1, name: '0'},
    {bits:  1, name: 'BPFRZ'},
    {bits:  1, name: 'LCOFIFRZ'},
    {bits:  3, name: 'DEPTH'},
    {bits:  17, name: '0'},
    {bits:  1, name: 'EXCINH'},
    {bits:  1, name: 'INTRINH'},
    {bits:  1, name: 'TRETINH'},
    {bits:  1, name: 'NTBREN'},
    {bits:  1, name: 'TKBRINH'},
    {bits:  2, name: '0'},
    {bits:  1, name: 'INDCALLINH'},
    {bits:  1, name: 'DIRCALLINH'},
    {bits:  1, name: 'INDJMPINH'},
    {bits:  1, name: 'DIRJMPINH'},
    {bits:  1, name: 'CORSWAPINH'},
    {bits:  1, name: 'RETINH'},
    {bits:  1, name: 'INDOJMPINH'},
    {bits:  1, name: 'DIROJMPINH'},
    {bits:  12, name: '0'},
    {bits:  4, name: 'Custom'},
], config:{lanes: 8, hspace:1024}}
....

.Machine Control Transfer Record Control Field Definitions
[width="100%",cols="20%,80%",options="header",]
|===
|Field |Description
|M, S, U |Enable transfer recording in the selected privileged mode(s).  If the H extension is implemented, VS and VU modes can be enabled from <<_virtual_supervisor_control_transfer_record_control_vsctrcontrol, `vsctrcontrol`>>.  

|RASEMU |Enables <<RAS (Return Address Stack) Emulation Mode>>.

|MTE |Enables recording of traps to M-mode when M=0, if any intervening privilege modes are enabled for external traps as well.  See <<_external_traps, External Traps>>.

|STE |Enables recording of traps to S-mode when S=0, if any intervening privilege modes are enabled for external traps as well.  See <<_external_traps, External Traps>>.

|BPFRZ |Set `sctrstatus`.FROZEN on a breakpoint exception that traps to M-mode or S-mode. See <<_freeze, Freeze>>.

|LCOFIFRZ |Set `sctrstatus`.FROZEN on local counter overflow interrupt (LCOFI) that traps to M-mode or S-mode. See <<_freeze, Freeze>>.

|DEPTH[2:0] a|
WARL field that selects the depth of the CTR buffer. Encodings:

‘000 - 16

‘001 - 32

‘010 - 64

‘011 - 128

‘100 - 256

'11x - reserved

The depth of the CTR buffer dictates the number of entries to which the
hardware records transfers. For a depth of N, the hardware
records transfers to entries 0..N-1. All <<_entry_registers, entry registers>> read as '0' and are read-only when the selected entry is in the range N to 255.  When the depth is increased, the newly accessible entries contain unspecified but legal values.

The maximum and minimum DEPTH values supported by an implementation is implementation-specific, but all values in between must also be supported.  If software writes a DEPTH value above the maximum supported, DEPTH must read back the maximum supported value.  If software writes a DEPTH value below the minimum supported, DEPTH must read back the minimum supported value.  An implementation may opt to hardcode some or all of the bits in this field, depending on the supported depth value(s). See <<_discovery, Discovery>>.  

|EXCINH |Inhibit recording of exceptions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|INTRINH |Inhibit recording of interrupts.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|TRETINH |Inhibit recording of trap return instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|NTBREN |Enable recording of not-taken branch instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|TKBRINH |Inhibit recording of taken branch instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|INDCALLINH |Inhibit recording of indirect call instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|DIRCALLINH |Inhibit recording of direct call instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|INDJUMPINH |Inhibit recording of indirect jump instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|DIRJUMPINH |Inhibit recording of direct jump instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|CORSWAPINH |Inhibit recording of co-routine swap instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|RETINH |Inhibit recording of function return instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|INDOJMPINH |Inhibit recording of other indirect jump instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|DIROJMPINH |Inhibit recording of other direct jump instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.
|`Custom`[3:0] | WARL bits designated for custom use.  The reset value must correspond to standard behavior.  See <<Custom Extensions>>.
|===

All fields are optional except for M, BPFRZ, and DEPTH.  All unimplemented fields are read-only 0.  All implemented fields are writable, though DEPTH may contain some read-only 1 bits.  S must be writable if S-mode is implemented, and U must be writable if U-mode is implemented.  If the Smcofpmf/Sscofpmf extension is implemented, LCOFIFRZ must be writable.

[NOTE]
[%unbreakable]
====
_Software may choose to use a depth less than the maximum supported to reduce the latency of saving and restoring CTR state, or to emulate the maximum depth supported by other implementations, for example, during VM migration._

_When reducing CTR depth, software should execute <<_ctr_clear_operation, CTRCLEAR>>.  This ensures that newly accessible CTR entries have deterministic values._
====

[WARNING]
====
_DEPTH encodings above 256 are reserved, in order to avoid needing to reserve up to 2048 `*iselect` values for CTR._
====

=== Supervisor Control Transfer Record Control (`sctrcontrol`)

The `sctrcontrol` register provides supervisor mode access to a subset of <<_machine_control_transfer_record_control_mctrcontrol, `mctrcontrol`>>.

Bits 0 and 8 in `sctrcontrol` are read-only 0. As a result, the M and MTE fields in `mctrcontrol` are not accessible through `sctrcontrol`.  All other `mctrcontrol` fields are accessible through `sctrcontrol`.

=== Virtual Supervisor Control Transfer Record Control (`vsctrcontrol`)

If the H extension is implemented, the `vsctrcontrol` register is a 64-bit read/write register that is VS-mode's version of supervisor register `sctrcontrol`.  When V=1, `vsctrcontrol` substitutes for the usual `sctrcontrol`, so instructions that normally read or modify `sctrcontrol` actually access `vsctrcontrol` instead.

.Virtual Supervisor Control Transfer Record Control Register Format
[wavedrom, , ]
....
{reg: [    
    {bits:  1, name: '0'},
    {bits:  1, name: 'VS'},
    {bits:  1, name: 'VU'},
    {bits:  4, name: '0'},
    {bits:  1, name: 'RASEMU'},
    {bits:  1, name: '0'},
    {bits:  1, name: 'VSTE'},
    {bits:  1, name: '0'},
    {bits:  1, name: 'BPFRZ'},
    {bits:  1, name: 'LCOFIFRZ'},
    {bits:  3, name: 'DEPTH'},
    {bits:  17, name: '0'},
    {bits:  1, name: 'EXCINH'},
    {bits:  1, name: 'INTRINH'},
    {bits:  1, name: 'TRETINH'},
    {bits:  1, name: 'NTBREN'},
    {bits:  1, name: 'TKBRINH'},
    {bits:  2, name: '0'},
    {bits:  1, name: 'INDCALLINH'},
    {bits:  1, name: 'DIRCALLINH'},
    {bits:  1, name: 'INDJMPINH'},
    {bits:  1, name: 'DIRJMPINH'},
    {bits:  1, name: 'CORSWAPINH'},
    {bits:  1, name: 'RETINH'},
    {bits:  1, name: 'INDOJMPINH'},
    {bits:  1, name: 'DIROJMPINH'},
    {bits:  12, name: '0'},
    {bits:  4, name: 'Custom'},
], config:{lanes: 8, hspace:1024}}
....

.Virtual Supervisor Control Transfer Record Control Field Definitions
[width="100%",cols="20%,80%",options="header",]
|===
|Field |Description 
|VS, VU |Enable transfer recording in the selected privileged mode(s).  

|VSTE |Enables recording of traps to VS-mode when VS=0.  See <<_external_traps, External Traps>>.

|BPFRZ |Set `sctrstatus`.FROZEN on a breakpoint exception that traps to VS-mode. See <<_freeze, Freeze>>.

|LCOFIFRZ |Set `sctrstatus`.FROZEN on local counter overflow interrupt (LCOFI) that traps to VS-mode. See <<_freeze, Freeze>>.

|DEPTH[2:0] |Provides read-only access to the `sctrcontrol`.DEPTH field  
2+|Other field definitions match those of <<_supervisor_control_transfer_record_control_sctrcontrol, `sctrcontrol`>>.  The optional fields implemented in `vsctrcontrol` should match those implemented in `sctrcontrol`.
|===

[NOTE]
[%unbreakable]
====
_Bit positions for VSTE, VS, and VU in `vsctrcontrol` match those for STE, S, and U in `sctrcontrol`, respectively. This is to accommodate an (unenlightened) guest OS that is unaware it is running with V=1._
====

[NOTE]
[%unbreakable]
====
`vsctrcontrol`.DEPTH _is a read-only copy of `sctrcontrol`.DEPTH in order to allow a hypervisor to dictate the depth used by a guest.  This simplifies VM (guest) migration, by providing the hypervisor a means to require the guest to use a depth supported across all systems in the datacenter._
====

[WARNING]
[%unbreakable]
====
_The TG deemed that, unlike the CTR status register or the CTR entry registers, the CTR control register should have a VS-mode version.  This allows a guest to manage the CTR configuration directly, without requiring traps to HS-mode, while ensuring that the guest configuration (most notably the privilege mode enable bits) do not impact CTR behavior when V=0._

_The TG considered making `vsctrcontrol` pass-through `sctrcontrol` fields other than VS, VU, and VSTE.  This would simplify behavior on traps and trap returns between V=0 and V=1, since those shared CTR configuration fields would not change.  But this would be undesirable for host + guest usages, since it would require switching `sctrcontrol` on each V transition._
====

=== Supervisor Control Transfer Record Status (`sctrstatus`)

The `sctrstatus` register grants access to CTR status information and is updated by the hardware whenever CTR is active, which implies that the current privilege mode is enabled for recording and CTR is not frozen.

.Supervisor Control Transfer Record Status Register Format
[wavedrom, , ]
....
{reg: [    
    {bits:  8, name: 'WRPTR'},
    {bits:  23, name: '<i>WPRI</i>'},
    {bits:  1, name: 'FROZEN'},
], config:{lanes: 2, hspace:1024}}
....

.Supervisor Control Transfer Record Status Field Definitions
[width="100%",cols="15%,75%,10%",options="header",]
|===
|Field |Description |Access
|WRPTR |Indicates the physical CTR buffer entry to be written next.  Incremented on new transfers recorded (see <<_behavior, Behavior>>), and decremented on qualified returns when `mctrcontrol`.RASEMU=1 (see <<_ras_return_address_stack_emulation_mode, RAS (Return Address Stack) Emulation Mode>>).  For a given CTR depth (where depth = 2^(DEPTH+4)^), WRPTR wraps to 0 on an increment when the value matches depth-1, and to depth-1 on a decrement when the value is 0.  Bits above those needed to represent depth-1 (e.g., bits 7:4 for a depth of 16) are read-only 0. On depth changes, WRPTR holds an unspecified but legal value. |WARL 
|FROZEN |Inhibit transfer recording. See <<_freeze, Freeze>>. |WARL
|===

Undefined bits in `sctrstatus` are WPRI. Status fields may be added by future extensions,
and software should ignore but preserve any fields that it does not recognize.  Undefined  bits must be implemented as read-only 0, unless a <<_custom_extensions, custom extension>> is implemented and enabled.

[NOTE]
[%unbreakable]
====
_Logical entry 0, accessed via `mireg*` when `miselect`=0x200, is always the physical entry preceding the WRPTR entry ((WRPTR-1) % depth), where depth = 2^(DEPTH+4)^._
====
[NOTE]
[%unbreakable]
====
_Because the `sctrstatus` register is updated by hardware, writes should be performed with caution.  If a multi-instruction read-modify-write to `sctrstatus` is performed while CTR is active, and between the read and write a qualified transfer or trap that causes CTR freeze completes, a hardware update could be lost.  Software may wish to ensure that CTR is inactive before performing a read-modify-write, by ensuring that either `sctrstatus`.FROZEN=1, or that the current privilege mode is not enabled for recording._

_When restoring CTR state, `sctrstatus` should be written before CTR entry state is restored.  This ensures that the software writes to logical CTR entries modify the proper physical entries._
====
[NOTE]
[%unbreakable]
====
_Exposing the WRPTR provides a more efficient means for synthesizing CTR entries.  If a qualified control transfer is emulated, the emulator can simply increment the WRPTR, then write the synthesized record to entry 0.  If a qualified function return is emulated while RASEMU=1, the emulator can clear `ctrsource`.V for entry 0, then decrement the WRPTR._

_Exposing the WRPTR may also allow support for Linux perf's https://lwn.net/Articles/802821[[.underline]#stack stitching#] capability._
====

=== CSR Listing

[width="100%",cols="^12%,18%,70%",options="header",]
|===
| CSR Number | Name | Description
| 0x181 | `sctrcontrol` | Supervisor Control Transfer Records Control Register
| 0x183 | `sctrstatus` | Supervisor Control Transfer Records Status Register
| 0x281 | `vsctrcontrol` | Virtual Supervisor Control Transfer Records Control Register
| 0x381 | `mctrcontrol` | Machine Control Transfer Records Control Register
|===

[NOTE]
====
_Because the ROI of CTR is perceived to be low for RV32 implementations, CTR does not fully support RV32.  While control flow transfers in RV32 can be recorded, RV32 cannot access `__x__ctrcontrol`[63:32].  A future extension could add support for RV32, by adding 3 new CSRs (`mctrcontrolh`, `sctrcontrolh`, and `vsctrcontrolh`) to provide this access._
====

== Entry Registers

Control transfer records are stored in a CTR buffer, such that each buffer entry stores information about a single transfer.  The CTR buffer entries are logically accessed via the indirect register access mechanism defined by the
https://github.com/riscv/riscv-indirect-csr-access/releases[[.underline]#Smcsrind/Sscsrind#]
extension. The `miselect` index range 0x200 through 0x2FF is reserved for CTR
entries 0 through 255. When `miselect` holds a value in this range, `mireg` provides access to <<_control_transfer_record_source_ctrsource, `ctrsource`>>, `mireg2` provides access to <<_control_transfer_record_target_ctrtarget, `ctrtarget`>>, and `mireg3` provides access to <<_control_transfer_record_source_ctrdata, `ctrdata`>>.  In RV32, `mireg4` accesses `ctrdata`[63:32], otherwise `mireg4`, `mireg5`, and `mireg6` are read-only 0.

The standard indirect register access rules specified by Smcsrind/Sscsrind apply for CTR.  S-mode is able to access CTR entries using the `siselect`/`sireg*` interface, with the same behavior described for M-mode above.  Similarly, VS-mode is able to access CTR entries using `siselect` (really `vsiselect`) and `sireg*` (really `vsireg*`).  See <<_state_enable_access_control, State Enable Access Control>> for cases where CTR accesses from S-mode and VS-mode may be restricted.  

For `\*iselect` values in 0x200..0x2FF, `vsireg*` registers access the same entry register state as `mireg*` and `sireg*`, regardless of the privilege mode at the time of access.  There is not a separate set of entry registers for V=1.

[WARNING]
[%unbreakable]
====
_Implementations may opt not to preserve CTR entry state across clock-gated low-power states.  A bit to indicate this should be added to the https://github.com/riscv-non-isa/riscv-acpi-ffh/pull/3/files[[.underline]#ACPI spec#] upon ratification._
====

=== Control Transfer Record Source (`ctrsource`)

The `ctrsource` register contains the source program counter, which is the `pc` of the recorded control transfer instruction, or the epc of the recorded trap.  The valid (V) bit is set by the hardware when a transfer is recorded in the selected CTR buffer entry, and implies that
data in `ctrsource`, `ctrtarget`, and `ctrdata` is valid for this entry.

`ctrsource` is an MXLEN-bit WARL register that must be able to hold all valid virtual or physical addresses that can serve as a `pc`. It need not be able to hold any invalid addresses.  When XLEN < MXLEN, both explicit writes (by software) and implict writes (for recorded transfers) will be zero-extended.

.Control Transfer Record Source Register Format (RV32)
[wavedrom, , ]
....
{reg: [    
    {bits:  1, name: 'V'},
    {bits:  31, name: 'PC[31:1]'},
], config:{lanes: 1, hspace: 1024}}
....

.Control Transfer Record Source Register Format (RV64)
[wavedrom, , ]
....
{reg: [    
    {bits:  1, name: 'V'},
    {bits:  63, name: 'PC[63:1]'},
], config:{lanes: 1, hspace: 1024}}
....

[NOTE]
[%unbreakable]
====
_CTR entry registers are defined as MXLEN, despite the CSRs used to access them (`\*ireg*``) being XLEN, to ensure that entries recorded in RV64 are not truncated, as a result of CSR Width Modulation, on a transition to RV32._
====
[NOTE]
[%unbreakable]
====
_A transfer from an invalid address (which could only occur on an exception) may report a valid address in `ctrsource`.PC._
====

[WARNING]
[%unbreakable]
====
_If we believe a future standard or custom extension may define 1-byte opcodes, then we should not use bit 0 of `ctrsource` for the V field, nor bit 0 of `ctrtarget` for MISP.  The V bit could be moved to `ctrdata`, but that would mean software would always need to read `ctrdata`._
====
=== Control Transfer Record Target (`ctrtarget`)

The `ctrtarget` register contains the target (destination) program counter
of the recorded transfer. The optional MISP bit is set by the hardware
when the recorded transfer is an instruction whose target or
taken/not-taken direction was mispredicted by the branch predictor. MISP
is read-only 0 when not implemented.

`ctrtarget` is an MXLEN-bit WARL register that must be able to hold all valid virtual or physical addresses. It need not be able to hold any invalid addresses. When XLEN < MXLEN, both explicit writes (by software) and implict writes (by recorded transfers) will be zero-extended.

.Control Transfer Record Target Register Format (RV32)
[wavedrom, , ]
....
{reg: [    
    {bits:  1, name: 'MISP'},
    {bits:  31, name: 'PC[31:1]'},
], config:{lanes: 1, hspace: 1024}}
....

.Control Transfer Record Target Register Format (RV64)
[wavedrom, , ]
....
{reg: [    
    {bits:  1, name: 'MISP'},
    {bits:  63, name: 'PC[63:1]'},
], config:{lanes: 2, hspace: 1024}}
....

[NOTE]
[%unbreakable]
====
_A transfer to an invalid address may report a valid address in `ctrtarget`.PC._
====

=== Control Transfer Record Metadata (`ctrdata`)

The `ctrdata` register contains metadata for the recorded transfer. This
register must be implemented, though all fields within it are optional.
Unimplemented fields are read-only 0.  `ctrdata` is a 64-bit register.  

.Control Transfer Record Metadata Register Format
[wavedrom, , ]
....
{reg: [    
    {bits:  4, name: 'TYPE'},
    {bits:  11, name: '<i>WPRI</i>'},
    {bits:  1, name: 'CCV'},
    {bits:  16, name: 'CC'},
    {bits:  32, name: '<i>WPRI</i>'},
], config:{lanes: 2, hspace: 1024}}
....

.Supervisor Control Transfer Record Metadata Field Definitions
[width="100%",cols="15%,75%,10%",options="header",]
|===
|Field |Description |Access 
|TYPE[3:0] a|
Identifies the type of the control flow transfer recorded in the entry. Implementations that do not support this field will report 0.

0000 - Reserved

0001 - Exception

0010 - Interrupt

0011 - Trap return

0100 - Not-taken branch

0101 - Taken branch

0110 - Reserved

0111 - Reserved

1000 - Indirect call

1001 - Direct call

1010 - Indirect jump

1011 - Direct jump

1100 - Co-routine swap

1101 - Return

1110 - Other indirect jump

1111 - Other direct jump

|WARL 

|CCV |Cycle Count Valid. See <<_cycle_counting, Cycle Counting>>. |WARL 

|CC[15:0] |Cycle Count, composed of the Cycle Count Exponent (CCE, in
CC[15:12]) and Cycle Count Mantissa (CCM, in CC[11:0]). See
<<_cycle_counting, Cycle Counting>>. |WARL 
|===

Undefined bits in `ctrdata` are WPRI. Status fields may be added by future extensions, and software should ignore but preserve any fields that it does not recognize.  Undefined bits must be implemented as read-only 0, unless a <<_custom_extensions, custom extension>> is implemented and enabled.

[WARNING]
[%unbreakable]
====
_The TG has debated the merits of including a 3-bit privilege mode field in `ctrdata`.  
This would help in cases where multiple privilege modes are recorded, and existing mechanisms for discerning the mode (addressing conventions and kernel mmaps) do not apply or are not available.  But it would require some complexity to avoid exposing the presence of virtualization to a guest that is using CTR, and there is question about the value given that existing tools that use similar capabilities from other architectures do not require this information.  The TG has thus far opted not to standardize bits for privilege mode, but consensus within the TG has not been reached._
====
[NOTE]
[%unbreakable]
====
_Like the <<_transfer_type_filtering, Transfer Type Filtering>> bits in `mctrcontrol`, the ctrdata.TYPE bits leverage the E-trace itype encodings._
====

== Instructions
=== CTR Clear Operation

[WARNING]
====
_Instruction opcode and format TBD_
====

The CTRCLEAR instruction performs the following operations:

* Clears all <<_entry_registers, CTR entry registers>>, for all DEPTH values.
* Clears <<_supervisor_control_transfer_record_status_sctrstatus, `sctrstatus`>>.
* Clears the CTR cycle counter and CCV.  See <<_cycle_counting, Cycle Counting>> for details.

As a result, the next recorded transfer will have `ctrdata`.CCV=0.  If CTR is not active, any read of ctrsource, ctrtarget, ctrdata, or sctrstatus that follows CTRCLEAR will return the value 0.  

== State Enable Access Control

When Smstateen is implemented, the `mstateen0.CTR` bit controls access to CTR register state from privilege modes less privileged than M-mode.  When `mstateen0.CTR`=0 and the privilege mode is less privileged than M-mode, attempts to access `sctrcontrol`, `vsctrcontrol`, `sctrstatus`, `sireg*` when `siselect` is in 0x200..0x2FF, or `vsireg*` when `vsiselect` is in 0x200..0x2FF, raise an illegal instruction exception.  When `mstateen0.CTR`=1, accesses to CTR register state behave as described in <<_csrs, CSRs>> and <<_entry_registers, Entry Registers>> above.

When `mstateen0.CTR`=0, qualified control transfers executed in privilege modes less privileged than M-mode will continue to implicitly update <<_entry_registers, Entry Registers>> and <<_machine_control_transfer_record_status_sctrstatus, `sctrstatus`>>.

If the H extension is implemented and `mstateen0.CTR`=1, the `hstateen0.CTR` bit controls access to supervisor CTR state (`sctrcontrol`, `sctrstatus`, and `sireg*` when `siselect` is in 0x200..0x2FF) when V=1.  `hstateen0.CTR` is read-only 0 when `mstateen0.CTR`=0.

When `mstateen0.CTR`=1 and `hstateen0.CTR`=1, VS-mode accesses to supervisor CTR state behave as described in <<_csrs, CSRs>> and <<_entry_registers, Entry Registers>> above.  When `mstateen0.CTR`=1 and `hstateen0.CTR`=0, VS-mode accesses to supervisor CTR state raise a virtual instruction exception.

When `hstateen0.CTR`=0, qualified control transfers executed while V=1 will continue to implicitly update <<_entry_registers, Entry Registers>> and <<_machine_control_transfer_record_status_sctrstatus, `sctrstatus`>>.

The CTR bit is bit 54 in `mstateen0` and `hstateen0`.

[NOTE]
[%unbreakable]
====
_See the https://github.com/riscv/riscv-indirect-csr-access[[.underline]#Smcsrind/Sscsrind spec#] for how bit 60 in mstateen0 and hstateen0 can also restrict access to `sireg*`/`siselect` and `vsireg*`/`vsiselect` from privilege modes less privileged than M-mode._
====

== Behavior

CTR records qualified control transfers.  Control transfers are qualified if they meet the following criteria:

* The current privilege mode is enabled
* The transfer type is not inhibited
* `sctrstatus`.FROZEN is not set

Such qualified transfers update the <<_entry_registers, Entry Registers>> at logical entry 0.  As a result, older entries are pushed down the stack: the record previously in entry 0
moves to entry 1, the record in entry 1 moves to entry 2, and so on.  If the CTR buffer is full, the oldest recorded entry (previously at entry depth-1) is lost.

Recorded transfers will set the `ctrsource`.V bit to 1, and will update all implemented record fields. 

[NOTE]
[%unbreakable]
====
_In order to collect accurate and representative performance profiles while using CTR, it is recommended that hardware recording of control transfers incurs no added performance overhead, e.g., in the form of retirement or instruction execution restrictions that are not present when CTR is not recording transfers._
====

=== Privilege Mode Transitions

Transfers that change the privilege mode are a special case. What is
recorded, if anything, depends on whether the source privilege mode
and/or target privilege mode are enabled for recording, and on the transfer type (trap
or trap return).

Traps between enabled privilege modes are recorded as normal.  Traps from a disabled privilege mode to an enabled privilege mode are partially recorded, such that the `ctrsource`.PC is 0. Traps from an enabled mode to a disabled mode, known as external traps, are not recorded by default.  See <<_external_traps, External Traps>> for how they can be recorded.

Trap returns have similar treatment.  Trap returns between enabled privilege modes are recorded as normal.  Trap returns from an enabled mode back to a disabled mode are partially recorded, such that `ctrtarget`.PC is 0.  Trap returns from a disabled mode to an enabled mode are not recorded.

[NOTE]
====
_If privileged software is configuring CTR on behalf of less privileged software, it should ensure that its privilege mode enable bit (e.g., `sctrcontrol`.S for Supervisor software) is cleared before a trap return to the less privileged mode.  Otherwise the trap return will be recorded, leaking the privileged source `pc`._
====

Recording in Debug Mode is always inhibited. Transfers into and out of Debug Mode are never recorded.

=== Transfer Type Filtering

Default CTR behavior, when all transfer type filter bits (`mctrcontrol`[47:32]) are unimplemented or 0, is to record all control transfers within enabled privileged modes. By setting transfer type filter bits, software can opt out of recording select transfer types, or opt into recording non-default operations.  All transfer type filter bits are optional.

[NOTE]
[%unbreakable]
====
_Because not-taken branches are not recorded by default, the polarity of the associated enable bit (NTBREN) is the opposite of other bits associated with transfer type filtering (TKBRINH, RETINH, etc).  Non-default operations require opt-in rather than opt-out._
====

The transfer type filter bits leverage the type definitions specified
in Table 4.4, and described in Section 4.1.1, of the
https://github.com/riscv-non-isa/riscv-trace-spec/releases/download/v2.0rc2/riscv-trace-spec.pdf[[.underline]#RISC-V
Efficient Trace Spec v2.0#]. 

[NOTE]
[%unbreakable]
====
_If implementation of any transfer type filter bit results in reduced software performance, perhaps due to additional retirement restrictions, it is strongly recommended that this reduced performance apply only when the bit is set.  Alternatively, support for the bit may be omitted.  Maintaining software performance for the default CTR configuration, when all transfer type bits are cleared, is recommended._
====

==== External Traps

External traps are traps from a privilege mode enabled for CTR recording to a privilege mode that is not enabled for CTR recording.  By default external traps are not recorded, but privileged software running in the target mode of the trap can opt-in to allowing CTR to record external traps into
that mode. The MTE, STE, and VSTE bits allow M-mode, S-mode, and VS-mode, respectively, to opt-in.  

External trap recording depends not only on the target mode, but on any invtervening modes.  For instance, recording an external trap from U-mode to M-mode requires that MTE=STE=1.  Similarly, recording an external trap from VU-mode to HS-mode requires that STE=VSTE=1.

In records for external traps, the `ctrtarget`.PC is 0.
[NOTE]
[%unbreakable]
====
_No mechanism exists for recording external trap returns, because
the external trap record includes all relevant information, and gives
the trap handler (e.g., an emulator) the opportunity to modify the
record._
====
[WARNING]
[%unbreakable]
====
_Note that external trap recording does not depend on EXCINH/INTRINH.  Thus, when external traps are enabled, both external interrupts and external exceptions are recorded._

_STE allows recording of traps from U-mode to S-mode as well as from VS/VU-mode to HS-mode.  The hypervisor can flip STE before entering a guest if it wants different behavior for U-to-S vs VS/VU-to-HS.  A separate HTE bit could be defined, but ideally it would live in an hctrcontrol CSR, which is otherwise unneeded.  We could put it in [ms]ctrcontrol, but the bit position would need special treatment in `vsctrcontrol` (writable but has no impact on behavior)._
====

The table below provides details on recording of privilege mode
transfers. Standard dependencies on FROZEN and transfer type inhibits
also apply, but are not covered by the table.

[width="100%",cols="18%,17%,30%,35%",]
|===
.2+|*Transfer Type* .2+| *Source Mode* 2+|*Target Mode*
|*Enabled* |*Disabled*
.2+|*Trap* |*Enabled* |Recorded. |Recorded if `xTE`=1, where x is the target
mode and any intervening modes. `ctrtarget`.PC is 0, type is External Trap.

|*Disabled* |Recorded, `ctrsource`.PC is 0. |Not recorded.

.2+|*Trap Return* |*Enabled* |Recorded. |Recorded, `ctrtarget`.PC is 0.

|*Disabled* |Not recorded. |Not recorded.
|===

If external trap recording is implemented, MTE must be implemented, while STE must be implemented if S-mode is implemented, and VSTE must be implemented if the H extension is implemented.

=== Cycle Counting

The `ctrdata` register may optionally include a count of CPU cycles elapsed since the prior CTR record.  The elapsed cycle count value is represented by the CC field, which has a 12-bit mantissa component (Cycle Count Mantissa, or CCM) and a 4-bit exponent component (Cycle Count Exponent, or CCE). 

The elapsed cycle counter (CtrCycleCounter) increments at the same rate as the mcycle counter.  Only cycles while CTR is active are counted, where active implies that the current privilege mode is enabled for recording and CTR is not frozen.  The CC field is encoded such that CCE holds 0 if the CtrCycleCounter value is less than 4096, otherwise it holds the index of the most significant one bit in the CtrCycleCounter value, minus 12.  CCM holds CtrCycleCounter bits CCE+11:CCE.

The elapsed cycle count can then be calculated by software using the following formula:

[subs="specialchars,quotes"]
[%unbreakable]
----
if (CCE==0):
    return CCM
else:
    return (2^12^ + CCM) << CCE-1
endif
----

The CtrCycleCounter is reset on writes to `[ms]ctrcontrol`, and on execution of <<_ctr_clear_operation, CTRCLEAR>>, to ensure that any accumulated cycle counts do not persist across a context switch.  

An implementation that supports cycle counting must implement CCV and all
CCM bits, but may implement 0..4 exponent bits in CCE. Unimplemented CCE
bits are read-only 0. For implementations that support transfer type
filtering, it is recommended to implement at least 3 exponent bits. This
allows capturing the full latency of most functions, when recording only
calls and returns.  

The size of the CtrCycleCounter required to support each CCE width is given in the table below.

[width="60%", cols="10%,15%,15%", options="header",]
|===
| CCE bits | CtrCycleCounter bits | Max elapsed cycle value
| 0 | 12 | 4095
| 1 | 13 | 8191
| 2 | 15 | 32764
| 3 | 19 | 524224
| 4 | 27 | 134201344
|===

[NOTE]
[%unbreakable]
====
_When CCE>1, the granularity of the reported cycle count is reduced. For example, when CCE=3, the bottom 2 bits of the cycle counter are not reported, and thus the reported value increments only every 4 cycles.  As a result, the reported value represents an undercount of elapsed cycles for most cases (when the unreported bits are non-zero).  On average, the undercount will be (2^CCE-1^-1)/2.  Software can reduce the average undercount to 0 by adding (2^CCE-1^-1)/2 to each computed cycle count value when CCE>1._
====

The CC value saturates when all implemented bits in CCM and CCE are 1.

The CC value is only valid when the Cycle Count Valid (CCV) bit is set.  If CCV=0, the CC value might not hold the correct count of elapsed active cycles since the last recorded transfer.  The next record will have CCV=0 after a write to `[ms]ctrcontrol`, or execution of CTRCLEAR, since CtrCycleCounter is reset.  CCV should additionally be cleared after any other implementation-specific scenarios where active cycles might not be counted in CtrCycleCounter.

[WARNING]
[%unbreakable]
====
_The TG also considered the option of including an uncompressed 27-bit binary cycle counter value in `ctrdata`.  This would support the same maximum cycle value as the method described above, without any accuracy reduction.  However, it would consume all remaining bits in `ctrdata`[31:0], without adding meaningful value to users.  Though the uncompressed value would result in a slight reduction in hardware complexity, it would result in a non-trivial increase in area, to store an additional 11 bits per entry.  The TG agreed that the compressed mechanism is preferred._
====

=== RAS (Return Address Stack) Emulation Mode

When the optional `mctrcontrol`.RASEMU bit is implemented and set to 1, transfer recording behavior is altered to emulate the behavior of a return-address stack (RAS).

* Indirect and direct calls are recorded as normal
* Function returns pop the most recent call, by invalidating entry 0 (setting `ctrsource`.V=0)
and rotating the CTR buffer, such that (invalidated) entry 0 moves to
entry depth-1, and entries 1..depth-1 move to 0..depth-2.
* Co-routine swaps affect both a return and a call. Entry 0 is
overwritten.
* Other transfer types are inhibited
* <<_transfer_type_filtering, Transfer Type Filtering>> bits are ignored

[NOTE]
[%unbreakable]
====
_Profiling tools often collect call stacks along with each sample. Stack
walking, however, is a complex and often slow process that may require
recompilation (e.g., -fno-omit-frame-pointer) to work reliably. With RAS
emulation, tools can ask CTR hardware to save call stacks even for
unmodified code._

_CTR RAS emulation has limitations.  The CTR buffer will contain only partial stacks in cases where the call stack depth was greater than the CTR depth, CTR recording was enabled at a lower point in the call stack than main(), or where the CTR buffer was cleared since main()._

_The CTR stack may be corrupted in cases where calls and returns are not symmetric, such as with stack unwinding (e.g., setjmp/longjmp, C++ exceptions), where stale call entries may be left on the CTR stack, or user stack switching, where calls from multiple stacks may be intermixed._
====

[NOTE]
[%unbreakable]
====
_As described in <<_cycle_counting, Cycle Counting>>,
when CCV=1, the CC field provides the elapsed cycles since the prior CTR
entry was recorded. This introduces implementation challenges when
RASEMU=1 because, for each recorded call, there may have been several
recorded calls (and returns which “popped” them) since the prior
remaining call entry was recorded (see <<RAS (Return Address Stack) Emulation Mode>>). The implication is that returns that
pop a call entry not only do not reset the cycle counter, but instead
add the CC field from the popped entry to the counter. For simplicity,
an implementation may opt to record CCV=0 for all calls, or those whose parent call was popped, when RASEMU=1._
====

=== Freeze

When `sctrstatus`.FROZEN=1, transfer recording is inhibited.  This bit can be set by hardware, as described below, or by software.

When `mctrcontrol`.LCOFIFRZ=1 and a local counter overflow interrupt
(LCOFI) traps (as a result of an HPM counter overflow) to M-mode or to S-mode, `sctrstatus`.FROZEN is set by hardware. This inhibits CTR recording until software clears FROZEN. The LCOFI trap itself is not recorded.
[NOTE]
[%unbreakable]
====
_Freeze on LCOFI ensures that the execution path leading to the sampled
instruction (xepc) is preserved, and that the local counter overflow
interrupt (LCOFI) and associated Interrupt Service Routine (ISR) do not
displace any recorded transfer history state. It is the responsibility
of the ISR to clear FROZEN before xRET, if continued control transfer
recording is desired._

_LCOFI refers only to architectural traps directly caused by a local counter overflow. If a local counter overflow interrupt is recognized without a trap, for instance by reading mip, FROZEN is not automatically set._
====
Similarly, on a breakpoint exception that traps to M-mode or S-mode with `mctrcontrol`.BPFRZ=1, FROZEN is set by hardware. The breakpoint exception itself is not recorded.  

[NOTE]
[%unbreakable]
====
_Breakpoint exception refers to synchronous exceptions with a cause value of Breakpoint (3), regardless of source (ebreak, c.ebreak, Sdtrig); it does not include entry into Debug Mode, even in cores where this is implemented as an exception._
====

If the H extension is implemented, freeze behavior for LCOFIs and breakpoint exceptions that trap to VS-mode is determined by LCOFIFRZ and BPFRZ values, respectively, in `vsctrcontrol`.  This includes virtual LCOFIs pended by a hypervisor.

[NOTE]
[%unbreakable]
====
_When a guest uses the SBI Supervisor Software Events (SSE) extension, the LCOFI will trap to HS-mode, which will then invoke a registered VS-mode LCOFI handler routine.  If `vsctrcontrol`.LCOFIFRZ=1, the HS-mode handler will need to emulate the freeze by setting `sctrstatus`.FROZEN=1 before invoking the registered handler routine._
====


== Custom Extensions

Any custom CTR extension must be associated with a non-default value within the designated custom bits in `__x__ctrcontrol`.  When custom bits hold a value that enables the custom extension, the extension may alter standard CTR behavior, and may define new custom status fields within <<_supervisor_control_transfer_record_status_sctrstatus, `sctrstatus`>> or the <<_entry_registers, CTR entry registers>>.  All custom status fields, and standard status fields whose behavior is altered by the custom extension, must revert to standard behavior when the custom bits hold their default (reset) value.  This includes read-only 0 behavior for any bits undefined by any implemented standard extensions.

== Discovery

Software can discover the maximum supported CTR buffer depth value by writing '111 to `[ms]ctrcontrol.DEPTH`, then reading back the value.  Software can discover the minimum supported CTR buffer depth value by writing '000 to `[ms]ctrcontrol.DEPTH`, then reading back the value.

Software can discover implemented optional `__x__ctrcontrol` fields by writing all 1s to all defined fields, then reading the value back. Unimplemented fields are read-only
0.

Software can discover implemented optional CTR entry fields by writing
all 1s to all defined fields in the <<_entry_registers, Entry Registers>> at
entry 0, then reading them back. Unimplemented fields are read-only 0.

