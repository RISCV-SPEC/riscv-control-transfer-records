[[body]]
== CSRs

[NOTE]
====
_CSR field specifications (such as WARL and WPRI) can be found in the link:https://riscv.org/technical/specifications/[RISC-V Instruction Set Manual] vol. II (Privileged Architecture), section 2.3._
====

=== Machine Control Transfer Record Control (mctrcontrol)

The mctrcontrol register is a 64-bit read/write register that enables and configures the CTR capability.

[width="100%",options="header",cols="20%,46%,17%,17%"]
|===
|63:60 |59:48 |47 |46
|_Custom_ |0 |DIROJMPINH |INDOJMPINH
|===

[width="100%",options="header",]
|===
|45 |44 |43 |42 |41 |40
|RETINH |CORSWAPINH |DIRJUMPINH |INDJUMPINH |DIRCALLINH |INDCALLINH
|===

[width="100%",options="header",]
|===
|39 |38 |37 |36 |35 |34 |33 |32:20
|0 |ETEN |TKBRINH |NTBREN |TRETINH |INTRINH |EXCINH |0
|===

[width="100%",cols="16%,20%,12%,12%,12%,12%,12%",options="header",]
|===
|19:17 |16:13 |12 |11 |10 |9 |8
|DEPTH |0 |LCOFIFRZ |BPFRZ |RASEMU |STE |MTE
|===

[width="100%",options="header",]
|===
|7 4+|6:3 |2 |1 |0
|CLR 4+|0 |U |S |M
|===

[width="100%",cols="20%,80%",options="header",]
|===
|Field |Description
|M, S, U |Enable transfer recording in the selected privileged mode(s).  If the H extension is implemented, VS and VU modes can be enabled from <<_virtual_supervisor_control_transfer_record_control_vsctrcontrol, vsctrcontrol>>.  

|CLR |When written to 1, zeroes all implemented CTR entries, regardless of the current CTR depth. Also zeroes <<_machine_control_transfer_record_status_sctrstatus, sctrstatus>>.  Reads will always return 0 for this bit.  

|MTE |If ETEN=1, enables recording of traps to M-mode when M=0.  See <<_external_traps, External Traps>>.

|STE |If ETEN=1, enables recording of traps to S-mode when S=0.  See <<_external_traps, External Traps>>.

|RASEMU |Enables <<_ras_emulation_mode, RAS Emulation Mode>>.

|BPFRZ |Set sctrstatus.FROZEN on a breakpoint exception. See <<_freeze, Freeze>>.

|LCOFIFRZ |Set sctrstatus.FROZEN on local counter overflow interrupt (LCOFI). See <<_freeze, Freeze>>.

|DEPTH[3:0] a|
WARL field that selects the depth of the CTR buffer. Encodings:

‘000 - 16

‘001 - 32

‘010 - 64

‘011 - 128

‘100 - 256

'11x - reserved

The depth of the CTR buffer dictates the number of entries to which the
hardware will record transfers. For a depth of N, the hardware will
record transfers to entries 0..N-1. All <<_entry_registers, entry registers>> are
read-only 0 when the selected entry is in N..255.

The maximum DEPTH value supported is implementation-specific, but all lesser values must also be supported.  If software writes a DEPTH value above the maximum supported, DEPTH must read back the maximum supported value.  An implementation may opt to hardcode some or all of the bits in this field, based on the depth options supported. See <<_discovery, Discovery>>.  

|EXCINH |Inhibit recording of exceptions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|INTRINH |Inhibit recording of interrupts.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|TRETINH |Inhibit recording of trap return instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|NTBREN |Enable recording of not-taken branch instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|TKBRINH |Inhibit recording of taken branch instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|ETEN |Enable recording of external traps, or traps from an enabled mode to a disabled mode. If ETEN=MTE=1, external traps to M-mode will be recorded. If ETEN=STE=1, external traps to S-mode will be recorded.  See <<_external_traps, External Traps>>.

|INDCALLINH |Inhibit recording of indirect call instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|DIRCALLINH |Inhibit recording of direct call instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|INDJUMPINH |Inhibit recording of indirect jump instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|DIRJUMPINH |Inhibit recording of direct jump instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|CORSWAPINH |Inhibit recording of co-routine swap instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|RETINH |Inhibit recording of function return instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|INDOJMPINH |Inhibit recording of other indirect jump instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.

|DIROJMPINH |Inhibit recording of other direct jump instructions.  See <<_transfer_type_filtering, Transfer Type Filtering>>.
|Custom | Designated for custom use.  WARL.
|===

All fields are optional save for M, CLR, and DEPTH.  All unimplemented fields are read-only 0, while other fields are writable, though DEPTH may have some read-only 1 bits.  S must be writable if S-mode is implemented, and U must be writable if U-mode is implemented.

In RV32, mctrcontrol[63:32] can be accessed via mctrcontrolh.

[NOTE]
[%unbreakable]
====
_Software may opt to use a depth less than the maximum supported in order to reduce the latency of saving and restoring CTR state, or to emulate the maximum depth supported by other implementations, e.g. in cases of VM-migration._

_When reducing CTR depth, by writing mctrcontrol.DEPTH to a smaller value, software should set mctrcontrol.CLR.  This ensures that no transfer state is retained in the now-inaccessible entries above the new depth value._
====

=== Supervisor Control Transfer Record Control (sctrcontrol)

The sctrcontrol register provides supervisor mode access to a subset of <<_machine_control_transfer_record_control_mctrcontrol, mctrcontrol>>.

Bits 0 and 8 in sctrcontrol are read-only 0. As a result, the M and MTE fields in mctrcontrol are not accessible through sctrcontrol.  All other mctrcontrol fields are accessible through sctrcontrol.

In RV32, sctrcontrol[63:32] can be accessed via sctrcontrolh.

=== Virtual Supervisor Control Transfer Record Control (vsctrcontrol)

If the H extension is implemented, the vsctrcontrol register is a 64-bit read/write register that is VS-mode's version of supervisor register sctrcontrol.  When V=1, vsctrcontrol substitutes for the usual sctrcontrol, so instructions that normally read or modify sctrcontrol actually access vsctrcontrol instead.

[width="100%",options="header",cols="20%,46%,17%,17%"]
|===
|63:60 |59:48 |47 |46
|Custom (WARL) |0 |DIROJMPINH |INDOJMPINH
|===

[width="100%",options="header",]
|===
|45 |44 |43 |42 |41 |40
|RETINH |CORSWAPINH |DIRJUMPINH |INDJUMPINH |DIRCALLINH |INDCALLINH
|===

[width="100%",options="header",]
|===
|39 |38 |37 |36 |35 |34 |33 |32:20
|0 |ETEN |TKBRINH |NTBREN |TRETINH |INTRINH |EXCINH |0
|===

[width="100%",options="header",]
|===
2+|19:17 |16:13 |12 |11 |10 |9 |8
2+|DEPTH |0 |LCOFIFRZ |BPFRZ |RASEMU |VSTE |0
|===

[width="100%",options="header",]
|===
|7 4+|6:3 |2 |1 |0
|CLR 4+|0 |VU |VS |0
|===

[width="100%",cols="20%,80%",options="header",]
|===
|Field |Description 
|VS, VU |Enable transfer recording in the selected privileged mode(s).  

|VSTE |If ETEN=1, enables recording of traps to VS-mode when VS=0.  See <<_external_traps, External Traps>>.  
|DEPTH |Provides read-only access to the sctrcontrol.DEPTH field  
2+|Other field definitions match those of <<_supervisor_control_transfer_record_control_sctrcontrol, sctrcontrol>>.  The optional fields implemented in vsctrcontrol should match those implemented in sctrcontrol.
|===

[NOTE]
====
_Bit positions for VSTE, VS, and VU in vsctrcontrol match those for STE, S, and U in sctrcontrol, respectively. This is to accommodate an (unenlightened) guest OS that is unaware it is running with V=1._
====

[NOTE]
====
_vsctrcontrol.DEPTH is a read-only copy of sctrcontrol.DEPTH in order to allow a hypervisor to dictate the depth used by a guest.  This simplifies VM (guest) migration, by providing the hypervisor a means to require the guest to use a depth supported across all systems in the datacenter._
====

[NOTE]
====
_Because vsctrcontrol is active only when V=1, writing a 1 to vsctrcontrol.CLR in M-mode or S/HS-mode will not affect a clear._
====

In RV32, vsctrcontrol[63:32] can be accessed via vsctrcontrolh.

[WARNING]
====
_The TG deemed that, unlike the CTR status register or the CTR entry registers, the CTR control register should have a VS-mode version.  This allows a guest to manage the CTR configuration directly, without requiring traps to HS-mode, while ensuring that the guest configuration (most notably the privilege mode enable bits) do not impact CTR behavior when V=0._

_The TG considered making vsctrcontrol pass-through sctrcontrol fields other than VS, VU, and VSTE.  This would simplify behavior on traps and trap returns between V=0 and V=1, since those shared CTR configuration fields would not change.  But this would be undesirable for host + guest usages, since it would require switching sctrcontrol on each V transition._
====

=== Supervisor Control Transfer Record Status (sctrstatus)

The sctrstatus register provides access to CTR status information, and is updated by the hardware when CTR is active (in an enabled privilege mode and not frozen).

[width="100%",options="header",cols="15%,10%,10%,35%,30%"]
|===
| 31:28 | 27 | 26 | 25:8 | 7:0
|_Custom_ |FROZEN |WRAP |_WPRI_ |WRPTR
|===

[width="100%",cols="15%,75%,10%",options="header",]
|===
|Field |Description |Access
|WRPTR |Indicates the physical CTR buffer entry to be written next.  Incremented on new transfers recorded, and decremented on qualified returns when mctrcontrol.RASEMU=1.  Wraps on increment when the value matches the selected depth-1, and on decrement when the value is 0.  Bits above those needed to represent depth-1 (e.g., bits 7:4 for depth=16) are read-only 0. |WARL 
|WRAP   |Sticky indication that the WRPTR has wrapped.  Set when WRPTR has value depth-1 (where depth is based on mctrcontrol.DEPTH), and a CTR update causes WRPTR to be incremented. Cleared when WRPTR has value zero and a CTR update causes WRPTR to be decremented (which only happens on returns when RASEMU=1), and on CSR writes that set mctrcontrol.CLR.  |WARL
|FROZEN |Inhibit transfer recording. See <<_freeze, Freeze>>. |WARL
|Custom |Designated for custom use. |WPRI
|===

Bits 31:28 are reserved for custom extensions.

[NOTE]
====
_Logical entry 0, accessed via mireg* when miselect=0x200, is always the physical entry preceding the WRPTR entry (WRPTR-1 % depth)._
====
[NOTE]
====
_Because the sctrstatus register is updated by hardware, writes should be performed with caution.  If a multi-instruction read-modify-write to sctrstatus is performed while CTR is active, such that a qualified transfer, or trap that causes CTR freeze, completes between the read and the write, a hardware update could be lost._
====
[NOTE]
====
_Exposing the WRPTR provides a more efficient means for synthesizing CTR entries.  If a qualified control transfer is emulated, the emulator can simply increment the WRPTR, then write the synthesized record to entry 0.  If a qualified function return is emulated while RASEMU=1, the emulator can clear ctrsource.V for entry 0, then decrement the WRPTR._

_Exposing the WRPTR may also allow support for Linux perf's https://lwn.net/Articles/802821[[.underline]#stack stitching#] capability._
====

=== CSR Listing

[width="100%",cols="^12%,18%,70%",options="header",]
|===
| CSR Number | Name | Description
| 0x181 | sctrcontrol | Supervisor Control Transfer Records Control Register
| 0x182 | sctrcontrolh* | Supervisor Control Transfer Records Control Register upper 32 bits
| 0x183 | sctrstatus | Supervisor Control Transfer Records Status Register
| 0x281 | vsctrcontrol | Virtual Supervisor Control Transfer Records Control Register
| 0x282 | vsctrcontrolh* | Virtual Supervisor Control Transfer Records Control Register upper 32 bits
| 0x381 | mctrcontrol | Machine Control Transfer Records Control Register
| 0x382 | mctrcontrolh* | Machine Control Transfer Records Control Register upper 32 bits
|===
[cols=">", frame=none, grid=none]
|===
|* For RV32 only
|===

== Entry Registers

Control transfer records are stored in a CTR buffer, such that each buffer entry stores information about a single transfer.  The CTR buffer entries are logically accessed via the indirect register access mechanism defined by the
https://docs.google.com/document/u/0/d/1ZxTSUWX_9_VafWeA0l1ci9RFjmivLuZn-US9IbFOEWY/edit[[.underline]#Smcsrind/Sscsrind#]
extension. The miselect index range 0x200..0x2FF is reserved for CTR
entries 0..255. When miselect holds a value in this range, mireg
provides access to
<<_control_transfer_record_source_ctrsource, ctrsource>>,
mireg2 provides access to
<<_control_transfer_record_target_ctrtarget, ctrtarget>>,
and mireg3 provides access to
<<_control_transfer_record_metadata_ctrdata, ctrdata>>.  mireg4, mireg5, and mireg6 are read-only zero.

The standard indirect register access rules specified by Smcsrind/Sscsrind apply for CTR.  S-mode is able to access CTR entries using the siselect/sireg* interface, with the same behavior described for M-mode above.  Similarly, VS-mode is able to access CTR entries using siselect (really vsiselect) and sireg* (really vsireg*).  See <<_state_enable_access_control, State Enable Access Control>> for cases where CTR access from S-mode and VS-mode may be restricted.  

For \*iselect values in 0x200..0x2FF, vsireg* registers access the same entry register state as mireg* and sireg*, regardless of the privilege mode at the time of access.  There is not a separate set of entry registers for V=1.

Undefined bits in CTR entry registers are WPRI. Status fields may be added by future
extensions, and software should ignore but preserve any fields that it
does not recognize.

[WARNING]
====
_Implementations may opt not to preserve CTR entry state across clock-gated low-power states.  A bit to indicate this should be added to the https://github.com/riscv-non-isa/riscv-acpi-ffh/pull/3/files[[.underline]#ACPI spec#] upon ratification._
====

=== Control Transfer Record Source (ctrsource)

The ctrsource register contains the source PC, which is the PC of the recorded control transfer instruction, or the epc of the recorded trap.  The valid (V) bit is set by the hardware when a transfer is recorded in the selected CTR buffer entry, and implies that
data in ctrsource, ctrtarget, and ctrdata is valid for this entry.

ctrsource is an MXLEN-bit WARL register that must be able to hold all valid virtual addresses. It need not be able to hold an invalid address.  When XLEN < MXLEN, software access via *ireg will access only the lower XLEN bits of ctrsource, and implict writes (by recorded transfers) will be zero-extended.

[width="100%",cols="18%,72%,10%",options="header",]
|===
|MXLEN-1:XLEN |XLEN-1:1 |0
|0 |PC[XLEN-1:1] |V
|===

[NOTE]
====
_CTR entry registers are defined as MXLEN, despite the CSRs used to access them (\*ireg*) being XLEN, to ensure that entries recorded in RV64 are not truncated, as a result of CSR Width Modulation, on a transition to RV32._
====
[NOTE]
====
_A transfer from an invalid address (which could only occur on an exception) may report a valid address in ctrsource.PC._
====

[WARNING]
====
_If we believe a future standard or custom extension may define 1-byte opcodes, then we should not use bit 0 of ctrsource for the V field, nor bit 0 of ctrtarget for MISP.  The V bit could be moved to ctrdata, but that would mean software would always need to read ctrdata._
====
=== Control Transfer Record Target (ctrtarget)

The ctrtarget register contains the target (destination) PC
of the recorded transfer. The optional MISP bit is set by the hardware
when the recorded transfer is an instruction whose target or
taken/not-taken direction was mispredicted by the branch predictor. MISP
is read-only 0 when not implemented.

ctrtarget is an MXLEN-bit WARL register that must be able to hold all valid virtual addresses. It need not be capable of holding an invalid address. When XLEN < MXLEN, software access via *ireg2 will access only the lower XLEN bits of ctrtarget, and implict writes (by recorded transfers) will be zero-extended.

[width="100%",cols="18%,72%,10%",options="header",]
|===
|MXLEN-1:XLEN |XLEN-1:1 |0
|0 |PC[XLEN-1:1] |MISP
|===

[NOTE]
====
_A transfer to an invalid address may report a valid address in ctrtarget.PC._
====

=== Control Transfer Record Metadata (ctrdata)

The ctrdata register contains metadata for the recorded transfer. This
register is required, though all fields within it are optional.
Unimplemented fields are read-only 0.

ctrdata is an MXLEN-bit register.  When XLEN < MXLEN, software access via *ireg3 will access only the lower XLEN bits of ctrdata.  

[width="100%",options="header",]
|===
4+|MXLEN-1:32 3+|31:16 |15 2+|14:4 2+|3:0
4+|_WPRI_ 3+|CC |CCV 2+|_WPRI_ 2+|TYPE
|===

[width="100%",cols="15%,75%,10%",options="header",]
|===
|Field |Description |Access 
|TYPE[3:0] a|
Identifies the type of the control flow transfer recorded in the entry. Implementations that do not support this field will report 0.

0000 - Reserved

0001 - Exception

0010 - Interrupt

0011 - Trap return

0100 - Not-taken branch

0101 - Taken branch

0110 - Reserved

0111 - Reserved

1000 - Indirect call

1001 - Direct call

1010 - Indirect jump

1011 - Direct jump

1100 - Co-routine swap

1101 - Return

1110 - Other indirect jump

1111 - Other direct jump

|WARL 

|CCV |Cycle Count Valid. See <<_cycle_counting, Cycle Counting>>. |WARL 

|CC[15:0] |Cycle Count, composed of the Cycle Count Exponent (CCE, in
CC[15:12]) and Cycle Count Mantissa (CCM, in CC[11:0]). See
<<_cycle_counting, Cycle Counting>>. |WARL 
|===

[WARNING]
====
_The TG has debated the merits of including a 3-bit privilege mode field in ctrdata.  
This would help in cases where multiple privilege modes are recorded, and existing mechanisms for discerning the mode (addressing conventions and kernel mmaps) do not apply or are not available.  But it would require some complexity to avoid exposing the presence of virtualization to a guest that is using CTR, and there is question about the value given that existing tools that use similar capabilities from other architectures do not require this information.  The TG has thus far opted not to standardize bits for privilege mode, but consensus within the TG has not been reached._
====
[NOTE]
====
_Like the <<_transfer_type_filtering, Transfer Type Filtering>> bits in mctrcontrol, the ctrdata.TYPE bits leverage the E-trace itype encodings._
====

== State Enable Access Control

When Smstateen is implemented, the mstateen0.CTR bit controls access to CTR register state from privilege modes less privileged than M-mode.  When mstateen0.CTR=0, attempts from privilege modes less privileged than M-mode to access sctrcontrol, vsctrcontrol, sctrstatus, sireg* when siselect is in 0x200..0x2FF, or vsireg* when vsiselect is in 0x200..0x2FF, raise an illegal instruction exception.  When mstateen0.CTR=1, accesses to CTR register state behave as described in <<_csrs, CSRs>> and <<_entry_registers, Entry Registers>> above.

When mstateen0.CTR=0, qualified control transfers executed in privilege modes less privileged than M-mode will continue to implicitly update <<_entry_registers, Entry Registers>> and <<_machine_control_transfer_record_status_sctrstatus, sctrstatus>>.

If the H extension is implemented and mstateen0.CTR=1, the hstateen0.CTR bit controls access to supervisor CTR state (sctrcontrol, sctrstatus, and sireg* when siselect is in 0x200..0x2FF) when V=1.  When mstateen0.CTR=1 and hstateen0.CTR=1, VS-mode accesses to supervisor CTR state behave as described in <<_csrs, CSRs>> and <<_entry_registers, Entry Registers>> above.  When mstateen0.CTR=1 and hstateen0.CTR=0, VS-mode accesses to supervisor CTR state that would have completed successfully if hstateen0.CTR was set raise a virtual instruction exception, while others raise an illegal instruction exception.

When hstateen0.CTR=0, qualified control transfers executed while V=1 will continue to implicitly update <<_entry_registers, Entry Registers>> and <<_machine_control_transfer_record_status_sctrstatus, sctrstatus>>.

The CTR bit is bit 55 in mstateen0 and hstateen0.

[NOTE]
====
_Bit 60 in mstateen0, defined by Smcsrind, can also restrict access to sireg*/siselect and vsireg*/vsiselect from privilege modes less privileged than M-mode._
====

== Behavior

CTR records qualified control transfers.  Control transfers are qualified if they meet the following criteria:

* The current privilege mode is enabled
* The transfer type is not inhibited
* sctrstatus.FROZEN is not set

Such qualified transfers update the <<_entry_registers, Entry Registers>> at logical entry 0, such that older entries are pushed down the stack (the record previously in entry 0 is pushed to entry 1, the record previously in entry 1 is pushed to entry 2, etc). If the CTR buffer is full, the oldest recorded entry (previously at depth-1) is lost.

Recorded transfers will set the ctrsource.V bit to 1, and will update all implemented record fields. 

[NOTE]
====
_In order to collect accurate and representative performance profiles while using CTR, it is recommended that hardware recording of control transfers incurs no added performance overhead, e.g., in the form of retirement or instruction execution restrictions that are not present when CTR is not recording transfers._
====

=== Privilege Mode Transitions

Transfers that change the privilege mode are a special case. What is
recorded, if anything, depends on whether the source mode
and/or target mode are enabled for recording, and on the transfer type (trap
or trap return).

Traps and trap returns between enabled modes are recorded as normal.
Traps from a disabled mode to an enabled mode, and trap returns from
an enabled mode back to a disabled mode, are partially recorded. In
such cases, the PC from the disabled mode (source PC for traps, and
target PC for trap returns) is 0. Trap returns from a disabled mode to
a enabled mode are not recorded. Traps from an enabled mode to a
disabled mode, known as external traps, are not recorded by default,
but see <<_external_traps, External Traps>> for how they
can be recorded.

Recording in Debug Mode is always inhibited. Transfers into and out of Debug Mode are
never recorded.

=== Transfer Type Filtering

Default CTR behavior, when all transfer type filter bits (mctrcontrol[47:32]) are unimplemented or 0, is to record all control transfers within enabled privileged modes. By setting transfer type filter bits, software can opt out of recording select transfer types, or opt into recording non-default operations.  All transfer type filter bits are optional.

[NOTE]
[%unbreakable]
====
_Because External Traps and not-taken branches are not recorded by default, the polarity of the associated enable bits (ETEN and NTBREN) is the opposite of other bits associated with transfer type filtering (TKBRINH, RETINH, etc).  Non-default operations require opt-in rather than opt-out._
====

The transfer type filter bits leverage the type definitions specified
in Table 4.4, and described in Section 4.1.1, of the
https://github.com/riscv-non-isa/riscv-trace-spec/releases/download/v2.0rc2/riscv-trace-spec.pdf[[.underline]#RISC-V
Efficient Trace Spec v2.0#]. An exception is the ETEN bit, discussed in
<<_external_traps, External Traps>> below.

[NOTE]
====
_If implementation of any transfer type filter bit results in reduced software performance, perhaps due to additional retirement restrictions, it is strongly recommended that this reduced performance apply only when the bit is set.  Alternatively, support for the bit may be omitted.  Maintaining software performance for the default CTR configuration, when all transfer type bits are cleared, is recommended._
====

==== External Traps

External traps are traps from a privilege mode enabled for CTR recording to a privilege mode that is not enabled for CTR recording.  By default external traps are not recorded, but an optional handshake
mechanism exists to allow partial recording. Software running in the
target mode of the trap can opt-in to allowing CTR to record traps into
that mode even when the mode is not enabled for CTR recording. The MTE, STE, and VSTE bits
allow M-mode, S-mode, and VS-mode, respectively, to opt-in. Tools can
request to record External Traps by setting the ETEN bit. When an
External Trap occurs, only if both ETEN=1 and xTE=1, such that x is the
target privilege mode of the trap, will CTR record the trap. In such
cases, the target PC is 0.
[NOTE]
====
_The external trap handshake allows both system software and the tools
control over what is exposed. M-mode firmware may always set
mctrcontrol.MTE=1, but a user-mode profiler may not wish to see any
traps. The driver can set sctrcontrol.ETEN=0 to ensure that external
traps are not recorded. On the other hand, a guest may wish to record
external traps from VU-mode to VS-mode, but the hypervisor may not wish to expose
traps from VU/VS-mode to HS-mode. The guest will set ETEN=VSTE=1, but the hypervisor can
clear sctrcontrol.STE._

_No such mechanism exists for recording external trap returns, because
the external trap record includes all relevant information, and gives
the trap handler (e.g., an emulator) the opportunity to modify the
record._
====
[WARNING]
====
_Note that external trap recording does not depend on EXCINH/INTRINH, only on ETEN and MTE/STE.  Thus, when external traps are enabled, both external interrupts and external exceptions are recorded._

_STE allows recording of traps from U-mode to S-mode as well as from VS/VU-mode to HS-mode.  The hypervisor can flip STE before entering a guest if it wants different behavior for U-to-S vs VS/VU-to-HS.  A separate HTE bit could be defined, but ideally it would live in an hctrcontrol CSR, which is otherwise unneeded.  We could put it in [ms]ctrcontrol, but the bit position would need special treatment in vsctrcontrol (writable but has no impact on behavior)._
====


The table below provides details on recording of privilege mode
transfers. Standard dependencies on FROZEN and transfer type inhibits
also apply, but are not covered by the table.

[width="100%",cols="18%,17%,30%,35%",]
|===
.2+|*Transfer Type* .2+| *Source Mode* 2+|*Target Mode*
|*Enabled* |*Disabled*
.2+|*Trap* |*Enabled* |Recorded. |Recorded if ETEN=xTE=1, where x is target
mode. Target PC is 0, type is External Trap.

|*Disabled* |Recorded, Source PC is 0. |Not recorded.

.2+|*Trap Return* |*Enabled* |Recorded. |Recorded, Target PC is 0.

|*Disabled* |Not recorded. |Not recorded.
|===

If ETEN is implemented, MTE must be implemented as well, as must STE if
S-mode is implemented, and VSTE if VS-mode is implemented.

=== Cycle Counting

The ctrdata register may optionally include a count of CPU cycles
elapsed since the prior CTR record.  The elapsed cycle count value is represented by the CC field, which has a 12-bit mantissa component (Cycle Count Mantissa, or CCM) and a 4-bit exponent component (Cycle Count Exponent, or CCE). The elapsed cycle count can be calculated by software using the following formula:

[subs="specialchars,quotes"]
----
if (CCE==0):
    return CCM
else:
    return (2^12^ + CCM) << CCE-1
endif
----

[NOTE]
====
_When CCE>1, the granularity of the reported cycle count is reduced. For example, when CCE=3, the bottom 2 bits of the cycle counter are not reported, and thus the reported value increments only every 4 cycles.  As a result, the reported value represents an undercount of elapsed cycles for most cases (when the unreported bits are non-zero).  On average, the undercount will be (2^CCE-1^-1)/2.  Software can reduce the average undercount to 0 by adding (2^CCE-1^-1)/2 to each computed cycle count value when CCE>1._
====

The CC value is only valid when the Cycle Count Valid (CCV) bit is set. If CCV=0, the CC value may not hold the correct count of elapsed qualified cycles since the last recorded transfer.  Qualified cycles are those executed within an enabled privilege mode with FROZEN=0.  An implementation must clear CCV for the next recorded transfer upon a write to [ms]ctrcontrol, and in any other implementation-specific scenarios where qualified cycles may be not be counted.

An implementation that supports cycle counting must support CCV and all
CCM bits, but may support 0..4 exponent bits in CCE. Unimplemented CCE
bits are read-only 0. For implementations that support transfer type
filtering, it is recommended to support at least 3 exponent bits. This
allows capturing the full latency of most functions, when recording only
calls and returns.

The CC value saturates when all implemented bits in CCM and CCE are 1.

[WARNING]
====
_The TG also considered the option of including an uncompressed 27-bit binary cycle counter value in ctrdata.  This would support the same maximum cycle value as the method described above, without any accuracy reduction.  However, it would consume all remaining bits in ctrdata[31:0], without adding meaningful value to users.  Though the uncompressed value would result in a slight reduction in hardware complexity, it would result in a non-trivial increase in area, to store an additional 11 bits per entry.  The TG agreed that the compressed mechanism is preferred._
====

=== RAS Emulation Mode

When the optional mctrcontrol.RASEMU bit is implemented and set to 1, transfer recording behavior is altered to emulate the behavior of a return-address stack (RAS).

* Indirect and direct calls are recorded as normal
* Function returns pop the most recent call, by invalidating entry 0 (setting ctrsource.V=0)
and rotating the CTR buffer, such that (invalidated) entry 0 moves to
entry depth-1, and entries 1..depth-1 move to 0..depth-2.
* Co-routine swaps affect both a return and a call. Entry 0 is
overwritten.
* Other transfer types are inhibited
* <<_transfer_type_filtering, Transfer Type Filtering>> bits are ignored

[NOTE]
====
_Profiling tools often collect call stacks along with each sample. Stack
walking, however, is a complex and often slow process that may require
recompilation (e.g., -fno-omit-frame-pointer) to work reliably. With RAS
emulation, tools can ask CTR hardware to save call stacks even for
unmodified code._

_CTR RAS emulation has limitations.  The CTR buffer will contain only partial stacks in cases where the call stack depth was greater than the CTR depth, CTR recording was enabled at a lower point in the call stack than main(), or where the CTR buffer was cleared since main()._

_The CTR stack may be corrupted in cases where calls and returns are not symmetric, such as with stack unwinding (e.g., setjmp/longjmp, C++ exceptions), where stale call entries may be left on the CTR stack, or user stack switching, where calls from multiple stacks may be intermixed._
====

[NOTE]
====
_As described in <<_cycle_counting, Cycle Counting>>,
when CCV=1, the CC field provides the elapsed cycles since the prior CTR
entry was recorded. This introduces implementation challenges when
RASEMU=1 because, for each recorded call, there may have been several
recorded calls (and returns which “popped” them) since the prior
remaining call entry was recorded. The implication is that returns that
pop a call entry not only do not reset the cycle counter, but instead
add the CC field from the popped entry to the counter. For simplicity,
an implementation may opt to record CCV=0 for all calls, or those whose parent call was popped, when RASEMU=1._
====

=== Freeze

When sctrstatus.FROZEN=1, transfer recording is inhibited.  This bit can be set by hardware, as described below, or by software.

When mctrcontrol.LCOFIFRZ=1 and a local counter overflow interrupt
(LCOFI) traps (as a result of an HPM counter overflow), sctrstatus.FROZEN is set by the CPU. This inhibits CTR recording until software clears FROZEN. The LCOFI trap itself is not
recorded.
[NOTE]
====
_Freeze on LCOFI ensures that the execution path leading to the sampled
instruction (xepc) is preserved, and that the local counter overflow
interrupt (LCOFI) and associated Interrupt Service Routine (ISR) do not
displace any recorded transfer history state. It is the responsibility
of the ISR to clear FROZEN before xRET, if continued control transfer
recording is desired._

_LCOFI refers only to architectural traps directly caused by a local counter overflow. If a local counter overflow interrupt is recognized without a trap, for instance by reading mip, FROZEN is not automatically set._
====
Similarly, on a breakpoint exception with mctrcontrol.BPFRZ=1, FROZEN is
set by the CPU. The breakpoint exception itself is not recorded.  

[NOTE]
====
_Breakpoint exception refers to synchronous exceptions with a cause value of Breakpoint (3), regardless of source (ebreak, c.ebreak, Sdtrig); it does not include entry into Debug Mode, even in cores where this is implemented as an exception._
====

== Discovery

Software can discover the maximum supported CTR buffer depth value by writing '111 to [ms]ctrcontrol.DEPTH, then reading back the value.  The value read represents the maximum supported depth.

Software can discover implemented optional [ms]ctrcontrol fields by writing all 1s to all defined fields, then reading the value back. Unimplemented fields are read-only
0.

Software can discover implemented optional CTR entry fields by writing
all 1s to all defined fields in the <<_entry_registers, Entry Registers>> at
entry 0, then reading them back. Unimplemented fields are read-only 0.

