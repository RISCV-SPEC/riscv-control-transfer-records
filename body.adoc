== CSRs

=== Machine Control Transfer Record Control (mctrcontrol)

The mctrcontrol register enables and configures the CTR capability.
Reset value is 0.

[width="100%",options="header",]
|===
4+|63:48 |47 |46
4+|_WARL_ |DIROJMPINH |INDOJMPINH
|===

[width="100%",options="header",]
|===
|45 |44 |43 |42 |41 |40
|RETINH |CORSWAPINH |DIRJUMPINH |INDJUMPINH |DIRCALLINH |INDCALLINH
|===

[width="100%",options="header",]
|===
|39 |38 |37 |36 |35 |34 |33 |32:20
|_WARL_ |ETEN |BRINH |_WARL_ |TRETINH |INTRINH |EXCINH |_WARL_
|===

[width="100%",options="header",]
|===
|19:16 |15:14 |13 |12 |11 |10 |9 |8
|DEPTH |_WARL_ |LCOFIFRZ |BPFRZ |FROZEN |RASEMU |STE |MTE
|===

[width="100%",options="header",]
|===
|7 |6 |5 |4 |3 |2 |1 |0
|CLR |VSEN |SEN |VU |VS |U |S |M
|===

[width="100%",cols="21%,79%",options="header",]
|===
|Field |Description
|M,S,U,VS,VU |Enable transfer recording in the selected privileged
mode(s).

|SEN |Enable S-mode access to sctrcontrol, and access to CTR entries via
siselect and sireg*.

|VSEN |Enable VS-mode access to sctrcontrol, and access to CTR entries
via siselect and sireg*.

|CLR |When written to 1, zeroes all implemented CTR entries, regardless
of the current CTR depth. Reads will always return 0 for this bit.

|MTE |If ETEN=1, enables recording of traps to M-mode when M=0.

|STE |If ETEN=1, enables recording of traps to S-mode when S=0.

|RASEMU |Enables <<_ras_emulation_mode, RAS Emulation Mode>>.

|FROZEN |Inhibit transfer recording. See
<<_freeze, Freeze>>.

|BPFRZ |Set FROZEN on a breakpoint exception. See
<<_freeze, Freeze>>.

|LCOFIFRZ |Set FROZEN on local counter overflow interrupt (LCOFI). See
<<_freeze, Freeze>>.

|DEPTH[3:0] a|
WARL field that selects the depth of the CTR array. Encodings:

‘0000 - 16

‘0001 - 32

‘0011 - 64

‘0111 - 128

‘1111 - 256

The depth of the CTR array dictates the number of entries to which the
hardware will record transfers. For a depth of N, the hardware will
record transfers to entries 0..N-1. mireg, mireg2, and mireg3 are
read-only 0 when miselect is in N..255.

It is unspecified which, if any, pre-existing CTR records are preserved
on a depth change, and which pre-existing records may be over-written.
It is strongly recommended that software set CLR on any writes that
modify DEPTH, to ensure that no pre-existing record state remains in any
inaccessible upper entries (N..255).

Which DEPTH values are supported is implementation-specific. An
implementation may opt to hardcode some or all of the bits in this
field, based on the depth options supported. See
<<_discovery, Discovery>>.

|EXCINH |Inhibit recording of exceptions

|INTRINH |Inhibit recording of interrupts

|TRETINH |Inhibit recording of trap return instructions

|BRINH |Inhibit recording of taken branch instructions

|ETEN |Enable recording of external traps, or traps from an enabled mode
to an inhibited mode. If ETEN=MTE=1, external traps to M-mode will be
recorded. If ETEN=STE=1, external traps to S-mode will be recorded.

|INDCALLINH |Inhibit recording of indirect call instructions

|DIRCALLINH |Inhibit recording of direct call instructions

|INDJUMPINH |Inhibit recording of indirect jump instructions

|DIRJUMPINH |Inhibit recording of direct jump instructions

|CORSWAPINH |Inhibit recording of co-routine swap instructions

|RETINH |Inhibit recording of function return instructions

|INDOJMPINH |Inhibit recording of indirect other jump instructions

|DIROJMPINH |Inhibit recording of direct other jump instructions
|===

M, CLR, and DEPTH are required fields. S and SEN are required if S-mode
is implemented. U is required if U-mode is implemented. VS, VU, and VSEN
are required if the H extension is implemented. All other fields are
optional. All unimplemented fields are read-only 0.

See also <<_transfer_type_filtering, Transfer Type Filtering>>, for details on bits 47:32.

In RV32, mctrcontrol[63:32] can be accessed via mctrcontrolh.

=== Supervisor Control Transfer Record Control (sctrcontrol)

The sctrcontrol register provides access to a subset of mctrcontrol. It
is accessible in S-mode when mctrcontrol.SEN=1; when SEN=0, S-mode
access to sctrcontrol results in an illegal instruction exception. It is
accessible in VS-mode when mctrcontrol.VSEN=mctrcontrol.SEN=1; when
VSEN=0 or SEN=0, VS-mode access to sctrcontrol results in an virtual
instruction exception.

Bits 0, 5, and 8 in sctrcontrol are read-only 0. As a result, S-mode and
VS-mode do not have access to the M, SEN, and MTE fields in mctrcontrol.

In RV32, sctrcontrol[63:32] can be accessed via sctrcontrolh.

If S-mode is not supported, access to sctrcontrol(h) results in an
illegal instruction exception.

=== Virtual Supervisor Control Transfer Record Control (vsctrcontrol)

The vsctrcontrol register is active when V=1. VS-mode accesses to
sctrcontrol are redirected to vsctrcontrol.

[width="100%",options="header",]
|===
4+|63:48 |47 |46
4+|_WARL_ |DIROJMPINH |INDOJMPINH
|===

[width="100%",options="header",]
|===
|45 |44 |43 |42 |41 |40
|RETINH |CORSWAPINH |DIRJUMPINH |INDJUMPINH |DIRCALLINH |INDCALLINH
|===

[width="100%",options="header",]
|===
|39 |38 |37 |36 |35 |34 |33 |32:20
|_WARL_ |ETEN |BRINH |_WARL_ |TRETINH |INTRINH |EXCINH |_WARL_
|===

[width="100%",options="header",]
|===
|19:16 |15:14 |13 |12 |11 |10 |9 |8
|DEPTH |_WARL_ |LCOFIFRZ |BPFRZ |FROZEN |RASEMU |VSTE |0
|===

[width="100%",options="header",]
|===
|7 |6 |5 2+|4:3 |2 |1 |0
|CLR |_WARL_ |0 2+|_WARL_ |VU |VS |0
|===

The VSTE bit enables recording of traps to VS-mode when VS=0, if ETEN=1.
Other field definitions match those of
<<_machine_control_transfer_record_control_mctrcontrol, mctrcontrol>>.
The optional fields supported in vsctrcontrol should match those
supported in mctrcontrol.

In RV32, vsctrcontrol[63:32] can be accessed via vsctrcontrolh.

If the H extension is not supported, access to vsctrcontrol(h) results
in an illegal instruction exception.
[NOTE]
====
_Bit positions for VSTE, VS, and VU in vsctrcontrol match those for STE,
S, and U in sctrcontrol, respectively. This is to accommodate an
(unenlightened) guest OS that is unaware it is running with V=1._

_To support nested virtualization uses, bits 6 and 4:3 should retain any
values written. This allows a hypervisor to observe values that an
unenlightened guest hypervisor intended to write to VSEN, VS, or VU._
====
== Entry Registers

CTR entries are accessed via the indirect register access mechanism
defined by the
https://docs.google.com/document/u/0/d/1ZxTSUWX_9_VafWeA0l1ci9RFjmivLuZn-US9IbFOEWY/edit[[.underline]#Smcsrind/Sscsrind#]
extension. The miselect index range 0x200..0x2FF is reserved for CTR
entries 0..255. When miselect holds an entry in this range, mireg
provides access to
<<_control_transfer_record_source_ctrsource, ctrsource>>,
mireg2 provides access to
<<_control_transfer_record_target_ctrtarget, ctrtarget>>,
and mireg3 provides access to
<<_control_transfer_record_metadata_ctrdata, ctrdata>>.
Accesses to mireg[456] while miselect is in 0x200..0x2FF cause an
illegal instruction exception.

[NOTE]
====
_There is no way to access the upper 32-bits of CTR entries from RV32.
This allows mireg[456] to be reserved for future CTR extensions._
====
By default, attempts to access sireg* while siselect is in 0x200..0x2FF
raise an illegal instruction exception from S-mode, or a virtual
instruction exception from VS-mode. If mctrcontrol.SEN=1, CTR entry
registers can be accessed from S-mode via sireg, sireg2, and sireg3. If
mctrcontrol.SEN=1 and mctrcontrol.VSEN=1, CTR entry registers can be
accessed from VS-mode via sireg, sireg2, and sireg3.

CTR entry registers are WPRI. Status fields may be added by future
extensions, and software should ignore but preserve any fields that it
does not recognize.

=== Control Transfer Record Source (ctrsource)

The ctrsource register contains the source virtual address (PC) of the
recorded transfer. The valid (V) bit is set by the hardware when a
transfer is recorded in the selected CTR array entry, and implies that
data in ctrsource, ctrtarget, and ctrdata is valid for this entry. All
fields are required.

[width="100%",cols="21%,70%,9%",options="header",]
|===
|MXLEN-1:XLEN |XLEN-1:1 |0
|_WPRI_ |PC[XLEN-1:1] |V
|===

=== Control Transfer Record Target (ctrtarget)

The ctrtarget register contains the target (destination) virtual address
of the recorded transfer. MISP is optional, it is set by the hardware
when the recorded transfer is an instruction whose target or
taken/not-taken direction was mispredicted by the branch predictor. MISP
is read-only 0 when not supported.

[width="100%",cols="21%,70%,9%",options="header",]
|===
|MXLEN-1:XLEN |XLEN-1:1 |0
|_WPRI_ |PC[XLEN-1:1] |MISP
|===

=== Control Transfer Record Metadata (ctrdata)

The ctrdata register contains metadata for the recorded transfer. This
register is required, though all fields within it are optional.
Unsupported fields are read-only 0.

[width="100%",options="header",]
|===
4+|63:32 2+|31:28 3+|27:16 |15 |14:4 2+|3:0
4+|_WPRI_ 2+|CCE 3+|CCM |CCV |_WPRI_ 2+|TYPE
|===

[width="100%",cols="22%,56%,12%,10%",options="header",]
|===
|Field |Description |Access |Reset
|TYPE[3:0] a|
Identifies the type of the control flow change recorded in CTR entry
ctrselect. Implementations that do not support this field will report 0.

0000 - Undefined

0001 - Exception

0010 - Interrupt

0011 - Trap return

0100 - Undefined

0101 - Taken branch

0110 - External trap

0111 - Reserved

1000 - Indirect call

1001 - Direct call

1010 - Indirect jump

1011 - Direct jump

1100 - Co-routine swap

1101 - Return

1110 - Other indirect jump

1111 - Other direct jump

|WLRL |0

|CCV |Cycle Count Valid. See link:#cycle-counting[[.underline]#Cycle
Counting#]. |WARL |0

|CC[15:0] |Cycle Count, composed of the Cycle Count Exponent (CCE, in
CC[15:12]) and Cycle Count Mantissa (CCM, in CC[11:0]). See
<<_cycle_counting, Cycle Counting>>. |WARL |0
|===
[NOTE]
====
_Like the transfer type inhibit bits in mctrcontrol, the ctrdata.TYPE
bits leverage the E-trace itype encodings, with the addition of External
Trap._
====
== Behavior

Control transfers are recorded by CTR if the following conditions are
met:

* The current privilege mode is enabled
* The transfer type is not inhibited
* mctrcontrol.FROZEN is not set

Recorded transfers update the <<_entry_registers, Entry Registers>> at index 0, such that older entries are pushed down the
stack. The record previously in entry 0 is pushed to entry 1, the record
previously in entry 1 is pushed to entry 2, etc. If the CTR array is
full, the oldest recorded entry (at DEPTH-1) is overwritten.

Recorded transfers will set the ctrsource.V bit to 1, and will update at
least the ctrsource.PC and ctrtarget.PC fields. Other record fields are
optional.

=== Privilege Mode Transitions

Transfers that change the privilege mode are a special case. What is
recorded, if anything, depends on whether the source (or origin) mode
and target mode are enabled for recording, and the transfer type (trap
or trap return).

Traps, and trap returns, between enabled modes are recorded as normal.
Traps from an inhibited mode to an enabled mode, and trap returns from
an enabled mode back to an inhibited mode, are partially recorded. In
such cases, the PC from the inhibited mode (source PC for traps, and
target PC for trap returns) is 0. Trap returns from an inhibited mode to
an enabled mode are not recorded. Traps from an enabled mode to an
inhibited mode, known as external traps, are not recorded by default,
but see <<_external_traps, External Traps>> for how they
can be recorded.

Debug Mode is always inhibited. Transfers into and out of Debug Mode are
never recorded.

=== Transfer Type Filtering

An implementation may opt to include support for filtering which
transfers are recorded, by transfer type. By default, all control
transfers within enabled privileged modes are recorded, but transfer
type filtering bits allow select types to be inhibited.

The transfer type inhibit bits leverage the type definitions specified
in Table 4.4, and described in Section 4.1.1, of the
https://github.com/riscv-non-isa/riscv-trace-spec/releases/download/v2.0rc2/riscv-trace-spec.pdf[[.underline]#RISC-V
Efficient Trace Spec v2.0#]. An exception is the ETEN bit, discussed in
<<_external_traps, External Traps>> below.

==== External Traps

By default external traps are not recorded, but an optional handshake
mechanism exists to allow partial recording. Software running in the
target mode of the trap can opt-in to allowing CTR to record traps into
that mode even when the mode is inhibited. The MTE, STE, and VSTE bits
allow M-mode, S-mode, and VS-mode, respectively, to opt-in. Tools can
request to record External Traps by setting the ETEN bit. When an
External Trap occurs, only if both ETEN=1 and xTE=1, such that x is the
target privilege mode of the trap, will CTR record the trap. In such
cases, the target PC is 0, and the transfer type (if supported) is
External Trap (6).
[NOTE]
====
_The external trap handshake allows both system software and the tools
control over what is exposed. M-mode firmware may always set
mctrcontrol.MTE=1, but a user-mode profiler may not wish to see any
traps. The driver can set sctrcontrol.ETEN=0 to ensure that external
traps are not recorded. On the other hand, a VM may wish to record
external traps from VU to VS, but the hypervisor may not wish to expose
traps from VU to HS. The VM will set ETEN=VSTE=1, but the hypervisor can
clear sctrcontrol.STE._

_No such mechanism exists for recording external trap returns, because
the external trap record includes all relevant information, and gives
the trap handler (e.g., an emulator) the opportunity to modify the
record._
====

The table below provides details on recording of privilege mode
transfers. Standard dependencies on FROZEN and transfer type inhibits
also apply, but are not covered by the table.

[width="100%",cols="18%,17%,30%,35%",options="header",]
|===
|*Transfer Type* a|
*Target Mode>*

*Source Mode*

|*Enabled* |*Inhibited*
|*Trap* |*Enabled* |Recorded. |Recorded if ETEN=xTE=1, where x is target
mode. Target PC is 0, type is External Trap.

| |*Inhibited* |Recorded, Source PC is 0. |Not recorded.

|*Trap Return* |*Enabled* |Recorded. |Recorded, Target PC is 0.

| |*Inhibited* |Not recorded. |Not recorded.
|===

If ETEN is implemented, MTE must be implemented as well, as must STE if
S-mode is implemented, and VSTE if VS-mode is implemented.

=== Cycle Counting

The ctrdata register may optionally include a count of CPU cycles
elapsed since the prior CTR record. The cycle counter increments only
while executing in an enabled privilege mode, and when FROZEN=0.

The elapsed cycle count value is represented by the CC field, which has
a mantissa component (Cycle Count Mantissa, or CCM) and an exponent
component (Cycle Count Exponent, or CCE). When CCE=0, CCM holds the raw
number of elapsed cycles. When CCE>0, the cycle count can be calculated
using the following formula:

[subs="specialchars,quotes"]
----
(2^12^ + CCM) << CCE-1
----

When CCE>1, the cycle count granularity is reduced from 1 to 2^CCE-1^.
The calculated value is the result of rounding the elapsed cycles down
to the nearest multiple of 2^CCE-1^.
[NOTE]
====
_This rounding results in an undercount of elapsed cycles, for most
cases, when CCE>1. On average, the undercount will be (2^CCE-1^-1)/2.
Software can reduce the average undercount to 0 by adding (2^CCE-1^-1)/2
to each computed cycle count value when CCE>1._
====

The cycle count value is only valid when the Cycle Count Valid (CCV) bit
is set. CCV will be cleared for the first transfer recorded after the
cycle counter stopped incrementing for any reason. This includes
execution in an inhibited privilege mode, FROZEN=1, or other
implementation-specific cases, such as entry to a clock-gated low-power
mode.

An implementation that supports cycle counting must support CCV and all
CCM bits, but may support 0..4 exponent bits in CCE. Unimplemented CCE
bits are read-only 0. For implementations that support transfer type
filtering, it is recommended to support at least 3 exponent bits. This
allows capturing the full latency of most functions, when recording only
calls and returns.

The CC value saturates when CCM and all implemented bits in CCE are 1.

=== RAS Emulation Mode

When mctrcontrol.RASEMU=1, transfer recording behavior is altered to
emulate the behavior of a return-address stack (RAS).

* Indirect and direct calls are recorded as normal
* Function returns pop the most recent call, by invalidating entry 0 (V=0)
and rotating the CTR array, such that (invalidated) entry 0 moves to
entry DEPTH-1, and entries 1:DEPTH-1 move to 0:DEPTH-2.
* Co-routine swaps affect both a return and a call. Entry 0 is
overwritten.
* Other transfer types are inhibited

[NOTE]
====
_Profiling tools often collect call stacks along with each sample. Stack
walking, however, is a complex and often slow process that may require
recompilation (e.g., -fno-omit-frame-pointer) to work reliably. With RAS
emulation, tools can ask CTR hardware to save call stacks even for
unmodified code._

_As described in <<_cycle_counting, Cycle Counting>>,
when CCV=1, the CC field provides the elapsed cycles since the prior CTR
entry was recorded. This introduces implementation challenges when
RASEMU=1 because, for each recorded call, there may have been several
recorded calls (and returns which “popped” them) since the prior
remaining call entry was recorded. The implication is that returns that
pop a call entry not only do not reset the cycle counter, but instead
add the CC field from the popped entry to the counter. For simplicity,
an implementation may opt to record CCV=0 for all calls when RASEMU=1._

_CTRs will contain only partial stacks in cases where the call stack
depth was greater than DEPTH, or where the CTR array was cleared since
main(). https://lwn.net/Articles/802821[[.underline]#Existing tool methodologies#] for stitching partial stacks collected across multiple
samples may be able to assist in identifying matching stacks._
====
=== Freeze

When mctrcontrol.LCOFIFRZ=1 and a local counter overflow interrupt
(LCOFI) is taken, mctrcontrol.FROZEN is set by the CPU. This inhibits
CTR recording until software clears FROZEN. The LCOFI trap itself is not
recorded.
[NOTE]
====
_Freeze on LCOFI ensures that the execution path leading to the sampled
instruction (xepc) is preserved, and that the local counter overflow
interrupt (LCOFI) and associated Interrupt Service Routine (ISR) do not
displace any recorded transfer history state. It is the responsibility
of the ISR to clear FROZEN before xRET, if continued control transfer
recording is desired._
====
Similarly, on a breakpoint exception with xctrcontrol.BPFRZ=1, FROZEN is
set by the CPU. The breakpoint exception itself is not recorded.

== Discovery

Software can discover supported CTR array depth values using the
following method:

* Write ‘0000 to mctrcontrol.DEPTH, then read back the value. The value
read represents the minimum supported depth.
* Write ‘1111 to mctrcontrol.DEPTH, then read back the value. The value
read represents the maximum supported depth.

All depths between the minimum and maximum are supported.

Software can discover implemented optional mctrcontrol fields by writing
all 1s, then reading the value back. Unimplemented fields are read-only
0.

Software can discover implemented optional CTR entry fields by writing
all 1s to the <<_entry_registers, Entry Registers>> at
entry 0, then reading them back. Unimplemented fields are read-only 0.

== Opens

* How to synthesize entries?
* Want a TOS for stack stitching?
* Want bit for missed transfer insts?
* Want priv mode recorded?
* CTR update performance event
* Option to record not-takens?
* Context filtering?
* Clear entries on depth change? Move depth field?
